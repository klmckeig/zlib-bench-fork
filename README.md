# zlib-bench

This repository contains some benchmarks for measuring the performance of various zlib implementations. It mainly serves as my personal backup and as a basis for the discussion on my OpenJDK enhancement proposal "[JDK-8249963: Make the zlib implementation selectively configurable at startup](https://bugs.openjdk.java.net/browse/JDK-8249963)". I didn't had time to bring this in a form which will make it useful for anybody else and I'll probably never have :) Feel free to use the information presented on this page and in this repository but don't blame me if the programs or scripts don't work for you out of the box!

All the tested libraries except "`isa-l`" are derived from and still fully API compatible with the original zlib implementation by Jean-loup Gailly and Mark Adler. The "[`isa-l`](https://github.com/intel/isa-l)" library is a clean-room, mostly assembler implementation of [RFC 1951](https://tools.ietf.org/html/rfc1951). It's generated output is fully compatible with that of the zlib library, but its API is different. I has been added to this comparison because of its outrageous inflation and especially deflation speed. 

The various zlib implementations are included as [submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules). So if you clone this repository you'll have to call `git submodule update --init --recursive` in order to get all the sources. "`zlib-ipp/`" is the same like the original "[`zlib-madler/`](https://github.com/madler/zlib.git)" but will be patched with [Intels IPP enhancements](https://software.intel.com/content/www/us/en/develop/articles/how-to-use-zlib-with-intel-ipp-optimization.html) during the build process. Each submodule comes with its own license. Please consult the corresponding documentation.

The "`ipp/`" directory contains the parts of the [Intel IPP library](https://software.intel.com/content/www/us/en/develop/tools/integrated-performance-primitives.html) which are required to build "`zlib-ipp`". They are covered by the [Intel Simplified Software License](ipp/license.txt).

Everything else is written or generated by me :)

Unfortunately this repository doesn't support a universal build system. On Linux/x86\_64 you can call `./build.sh` which is a simple wrapper for calling the respective build scripts in the `./build/<library>/` sub-directories. They will build the corresponding library into their sub-directory. On Linux/aarch64, Windows/x86\_64 and MacOS X, only `./build/zlib-chromium/build.sh` and `./build/zlib-cloudflare/build.sh` are known to work.

The `lib/` directory contains pre-build libraries of "`zlib-cloudflare`" and "`zlib-chromium`" for Linux/x86\_64, Linux/aarch64, Windows/x86\_64 and MacOS X.

The `benchmarks/` directory contains the [C](benchmarks/c/zbench.c) and [Java](benchmarks/java/io/simonis/ZBench.java) benchmarks I've used for my measurements. On Linux they can be build by calling `build/benchmarks/build.sh`. The directory also contains a bunch of shell scripts to run the benchmarks and create the graphs. Most of them will probably only work in my local environment but they may still serve as a blueprint if somebody wants to reproduce the results. To create graphs from the benchmark results you have to install [Vega-Lite](https://vega.github.io/vega-lite/usage/compile.html) and the corresponding command line utilities. [Vega-Desktop](https://github.com/vega/vega-desktop) can be useful for local editing of Vega-Lite graphs.

The `data/` directory contains the [Calgary](http://www.data-compression.info/Corpora/CalgaryCorpus/) and [Silesia](http://www.data-compression.info/Corpora/SilesiaCorpus/index.html) text corpora which are commonly used to benchmark and compare compression algorithms and implementations.

Finally, the `results/` directory contains the results of various benchmark runs on different platforms. For some of these benchmark results I've also created graphs which are in the corresponding sub-directories of the `graphs/` directory. 
